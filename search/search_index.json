{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nebulo Documentation : https://olirice.github.io/nebulo Source Code : https://github.com/olirice/nebulo Instant GraphQL API for PostgreSQL Reflect a highly performant GraphQL API from an existing PostgreSQL database. Nebulo is a python library for building GraphQL APIs on top of PostgreSQL. It has a command line interface for reflecting databases with 0 code or can be added to existing SQLAlchemy projects. TL;DR First, install nebulo $ pip install nebulo Then point the CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db Visit your shiny new GraphQL API at http://localhost:5034/graphiql Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"Introduction"},{"location":"#nebulo","text":"Documentation : https://olirice.github.io/nebulo Source Code : https://github.com/olirice/nebulo Instant GraphQL API for PostgreSQL Reflect a highly performant GraphQL API from an existing PostgreSQL database. Nebulo is a python library for building GraphQL APIs on top of PostgreSQL. It has a command line interface for reflecting databases with 0 code or can be added to existing SQLAlchemy projects.","title":"Nebulo"},{"location":"#tldr","text":"First, install nebulo $ pip install nebulo Then point the CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db Visit your shiny new GraphQL API at http://localhost:5034/graphiql Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"TL;DR"},{"location":"authentication/","text":"Authentication The approach to authentication and row level security were shamelessly borrowed from the postgraphile project, a similar (but much more mature) PostgreSQL to GraphQL project written in Javascript. Please see their security documentation for best practices when setting up secure auth for api user roles. For a complete usage, see the row level security example project Note that JWT identifier and JWT secret can be passed to the nebulo CLI via --jwt-identifier \"public.my_jwt\" and --jwt-secret \"my_jwt_secret\" to cause functions returning the JWT type to reflect correctly. If the JWT type contains a role field, that role will be used to execute SQL statements for authenticated user's requests. Anonymous users' requests execute with the connections default role unless a default role is passed using the --default-role option","title":"Authentication"},{"location":"authentication/#authentication","text":"The approach to authentication and row level security were shamelessly borrowed from the postgraphile project, a similar (but much more mature) PostgreSQL to GraphQL project written in Javascript. Please see their security documentation for best practices when setting up secure auth for api user roles. For a complete usage, see the row level security example project Note that JWT identifier and JWT secret can be passed to the nebulo CLI via --jwt-identifier \"public.my_jwt\" and --jwt-secret \"my_jwt_secret\" to cause functions returning the JWT type to reflect correctly. If the JWT type contains a role field, that role will be used to execute SQL statements for authenticated user's requests. Anonymous users' requests execute with the connections default role unless a default role is passed using the --default-role option","title":"Authentication"},{"location":"cli/","text":"Command Line Interface The CLI provides a path for deploying GraphQL APIs without writting any python code. For full usage see the row level security example Usage: neb [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. Commands: dump-schema Dump the GraphQL Schema to stdout or file run Run the GraphQL Web Server neb run Starts the GraphQL web server and serves the interactive documentation at http://<host>:<port>/graphiql Usage: neb run [OPTIONS] Run the GraphQL Web Server Options: -c, --connection TEXT Database connection string -p, --port INTEGER Web server port -h, --host TEXT Host address -w, --workers INTEGER Number of parallel workers -s, --schema TEXT SQL schema name --jwt-identifier TEXT JWT composite type identifier e.g. \"public.jwt\" --jwt-secret TEXT Secret key for JWT encryption --reload / --no-reload Reload if source files change --default-role TEXT Default PostgreSQL role for anonymous users --help Show this message and exit. neb dump-schema Export the GraphQL schema Usage: neb dump-schema [OPTIONS] Dump the GraphQL Schema to stdout or file Options: -c, --connection TEXT Database connection string -s, --schema TEXT SQL schema name -o, --out-file FILENAME Output file path --help Show this message and exit.","title":"CLI"},{"location":"cli/#command-line-interface","text":"The CLI provides a path for deploying GraphQL APIs without writting any python code. For full usage see the row level security example Usage: neb [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. Commands: dump-schema Dump the GraphQL Schema to stdout or file run Run the GraphQL Web Server","title":"Command Line Interface"},{"location":"cli/#neb-run","text":"Starts the GraphQL web server and serves the interactive documentation at http://<host>:<port>/graphiql Usage: neb run [OPTIONS] Run the GraphQL Web Server Options: -c, --connection TEXT Database connection string -p, --port INTEGER Web server port -h, --host TEXT Host address -w, --workers INTEGER Number of parallel workers -s, --schema TEXT SQL schema name --jwt-identifier TEXT JWT composite type identifier e.g. \"public.jwt\" --jwt-secret TEXT Secret key for JWT encryption --reload / --no-reload Reload if source files change --default-role TEXT Default PostgreSQL role for anonymous users --help Show this message and exit.","title":"neb run"},{"location":"cli/#neb-dump-schema","text":"Export the GraphQL schema Usage: neb dump-schema [OPTIONS] Dump the GraphQL Schema to stdout or file Options: -c, --connection TEXT Database connection string -s, --schema TEXT SQL schema name -o, --out-file FILENAME Output file path --help Show this message and exit.","title":"neb dump-schema"},{"location":"comment_directives/","text":"Comment Directives (Experimental) Some SQL comments are interpreted as directives and impact how nebulo reflects database entities. Exclude Usage @exclude ... Description The exclude directive can be applied to tables, views, table columns, or view columns. The mutation or query you'd like the entity to be omitted from may be described with a combination of the following. Column Allowed Params: create read update delete Table/View Allowed Params: create read read_one read_all update delete For example, the directive @exclude delete, update would make the entity immutable. Note: that read is equivalent to read_one and read_all together. Example The following examples show how you could exclude a column named password_hash from being exposed through the GraphQL API using SQL or SQLAlchemy. SQL create table account ( username text not null primary key , password_hash text not null , ); comment on column account . password_hash is E '@exclude create, read, update, delete' ; SQLAlchemy class Account ( Base ): __tablename__ = \"account\" username = Column ( Text , primary_key = False ) password_hash = Column ( Text , comment = \"@exclude create, read, update, delete\" ) Name Usage @name <name> Description Overrides the GraphQL type's associated with the commented entity. The directive can be applied to tables, views, table columns, or view columns. For example, the directive @ename ShippingAddress on an address table would result in the GraphQL type being named ShippingAddress .","title":"Comment Directives"},{"location":"comment_directives/#comment-directives-experimental","text":"Some SQL comments are interpreted as directives and impact how nebulo reflects database entities.","title":"Comment Directives (Experimental)"},{"location":"comment_directives/#exclude","text":"Usage @exclude ... Description The exclude directive can be applied to tables, views, table columns, or view columns. The mutation or query you'd like the entity to be omitted from may be described with a combination of the following. Column Allowed Params: create read update delete Table/View Allowed Params: create read read_one read_all update delete For example, the directive @exclude delete, update would make the entity immutable. Note: that read is equivalent to read_one and read_all together.","title":"Exclude"},{"location":"comment_directives/#example","text":"The following examples show how you could exclude a column named password_hash from being exposed through the GraphQL API using SQL or SQLAlchemy. SQL create table account ( username text not null primary key , password_hash text not null , ); comment on column account . password_hash is E '@exclude create, read, update, delete' ; SQLAlchemy class Account ( Base ): __tablename__ = \"account\" username = Column ( Text , primary_key = False ) password_hash = Column ( Text , comment = \"@exclude create, read, update, delete\" )","title":"Example"},{"location":"comment_directives/#name","text":"Usage @name <name> Description Overrides the GraphQL type's associated with the commented entity. The directive can be applied to tables, views, table columns, or view columns. For example, the directive @ename ShippingAddress on an address table would result in the GraphQL type being named ShippingAddress .","title":"Name"},{"location":"performance/","text":"Performance Performance Enabling Features: All queries are handled in a single round-trip to the database so there are no N+1 issues SQL queries only fetch requested fields SQL queries return JSON which significantly reduces database IO when joins are present Fully async Benchmarks Performance depends on network, number of workers, log level etc. Despite all that, here are rough figures with Postgres and the web server running on a mid-tier 2017 Macbook Pro. Benchmarking 0.0.0.0 (be patient) Server Software: uvicorn Server Hostname: 0.0.0.0 Server Port: 5034 Document Path: / Document Length: 310 bytes Concurrency Level: 10 Time taken for tests: 5.571 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 436000 bytes Total body sent: 245000 HTML transferred: 310000 bytes Requests per second: 179.49 [#/sec] (mean) Time per request: 55.712 [ms] (mean) Time per request: 5.571 [ms] (mean, across all concurrent requests) Transfer rate: 76.43 [Kbytes/sec] received 42.95 kb/s sent 119.37 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 17 55 18.7 52 98 Waiting: 17 55 18.7 51 98 Total: 18 55 18.7 52 98 Percentage of the requests served within a certain time (ms) 50% 52 66% 60 75% 65 80% 69 90% 80 95% 90 98% 94 99% 95 100% 98 (longest request) So approximately 180 requests/second responding in sub 100 milliseconds. Note that under normal load, response times are significantly faster. Percentage of the requests served within a certain time (ms) 50% 17 66% 19 75% 19 80% 20 90% 21 95% 24 98% 26 99% 30 100% 38 (longest request)","title":"Performance"},{"location":"performance/#performance","text":"Performance Enabling Features: All queries are handled in a single round-trip to the database so there are no N+1 issues SQL queries only fetch requested fields SQL queries return JSON which significantly reduces database IO when joins are present Fully async Benchmarks Performance depends on network, number of workers, log level etc. Despite all that, here are rough figures with Postgres and the web server running on a mid-tier 2017 Macbook Pro. Benchmarking 0.0.0.0 (be patient) Server Software: uvicorn Server Hostname: 0.0.0.0 Server Port: 5034 Document Path: / Document Length: 310 bytes Concurrency Level: 10 Time taken for tests: 5.571 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 436000 bytes Total body sent: 245000 HTML transferred: 310000 bytes Requests per second: 179.49 [#/sec] (mean) Time per request: 55.712 [ms] (mean) Time per request: 5.571 [ms] (mean, across all concurrent requests) Transfer rate: 76.43 [Kbytes/sec] received 42.95 kb/s sent 119.37 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 17 55 18.7 52 98 Waiting: 17 55 18.7 51 98 Total: 18 55 18.7 52 98 Percentage of the requests served within a certain time (ms) 50% 52 66% 60 75% 65 80% 69 90% 80 95% 90 98% 94 99% 95 100% 98 (longest request) So approximately 180 requests/second responding in sub 100 milliseconds. Note that under normal load, response times are significantly faster. Percentage of the requests served within a certain time (ms) 50% 17 66% 19 75% 19 80% 20 90% 21 95% 24 98% 26 99% 30 100% 38 (longest request)","title":"Performance"},{"location":"public_api/","text":"Public API Nebulo exposes a minimal public API to allow the internals to change freely. The public API is defined as anything documented on this page. For a complete example see the SQLAlchemy interop example from databases import Database from nebulo.gql.sqla_to_gql import sqla_models_to_graphql_schema from nebulo.server.exception import http_exception from nebulo.server.routes import GRAPHIQL_STATIC_FILES , get_graphql_route , graphiql_route from starlette.applications import Starlette from starlette.exceptions import HTTPException from starlette.routing import Mount , Route from myapp.sqla_models import Author , Book from myapp.config import DATABASE_URI def create_app ( connection_str , sqla_models ) -> Starlette : \"\"\"Create the Starlette app\"\"\" database = Database ( connection ) # Convert sqla models to graphql schema gql_schema = sqla_models_to_graphql_schema ( sqla_models = sqla_models ) graphql_path = '/' # Build the Starlette GraphQL Route graphql_route = get_graphql_route ( gql_schema = gql_schema , database = database , jwt_secret = jwt_secret , default_role = default_role , path = graphql_path , name = 'graphql' ) # Build the Starlette GraphiQL Route and StaticFiles graphiql_route = get_graphiql_route ( graphiql_path = '/graphiql' , graphql_path = graphql_path , name = 'graphiql' ) # Instantiate the Starlette app _app = Starlette ( routes = [ graphql_route , graphiql_route ], exception_handlers = { HTTPException : http_exception }, on_startup = [ database . connect ], on_shutdown = [ database . disconnect ], ) return _app # Instantiate the app APP = create_app ( connection_str = DATABASE_URI , sqla_models = [ Author , Book ]) Reflection Utilities for reflecting SQL entities as GraphQL entities. SQLA to GraphQL nebulo.gql.sqla_to_gql. sqla_models_to_graphql_schema ( sqla_models , sql_functions=None , jwt_identifier=None , jwt_secret=None ) Creates a GraphQL Schema from SQLA Models Parameters sqla_models : List[Type[SQLAModel]] = List of SQLAlchemy models to include in the GraphQL schema jwt_identifier : str = qualified path of SQL composite type to use encode as a JWT e.g. 'public.jwt' jwt_secret : str = Secret key used to encrypt JWT contents sql_functions = NOT PUBLIC API Server Helpers to serve the GraphQL schema. Routes nebulo.server.routes. get_graphql_route ( gql_schema , database , path='/' , jwt_secret=None , default_role=None , name=None ) Create a Starlette Route to serve GraphQL requests Parameters schema : Schema = A GraphQL-core schema database : Database = Database object for communicating with PostgreSQL path : str = URL path to serve GraphQL from, e.g. '/' jwt_secret : str = secret key used to encrypt JWT contents default_role : str = Default SQL role to use when serving unauthenticated requests name : str = Name of the GraphQL serving Starlette route nebulo.server.routes. get_graphiql_route ( graphiql_path='/graphiql' , graphql_path='/' , name='graphiql' ) Return mountable routes serving GraphiQL interactive API explorer Parameters graphiql_path : str = URL path to GraphiQL html page graphql_path : str = URL path to the GraphQL route name : str = Name for the mount Exception Handling nebulo.server.exception. http_exception ( request , exc ) Starlette exception handler converting starlette.exceptions.HTTPException into GraphQL responses","title":"API"},{"location":"public_api/#public-api","text":"Nebulo exposes a minimal public API to allow the internals to change freely. The public API is defined as anything documented on this page. For a complete example see the SQLAlchemy interop example from databases import Database from nebulo.gql.sqla_to_gql import sqla_models_to_graphql_schema from nebulo.server.exception import http_exception from nebulo.server.routes import GRAPHIQL_STATIC_FILES , get_graphql_route , graphiql_route from starlette.applications import Starlette from starlette.exceptions import HTTPException from starlette.routing import Mount , Route from myapp.sqla_models import Author , Book from myapp.config import DATABASE_URI def create_app ( connection_str , sqla_models ) -> Starlette : \"\"\"Create the Starlette app\"\"\" database = Database ( connection ) # Convert sqla models to graphql schema gql_schema = sqla_models_to_graphql_schema ( sqla_models = sqla_models ) graphql_path = '/' # Build the Starlette GraphQL Route graphql_route = get_graphql_route ( gql_schema = gql_schema , database = database , jwt_secret = jwt_secret , default_role = default_role , path = graphql_path , name = 'graphql' ) # Build the Starlette GraphiQL Route and StaticFiles graphiql_route = get_graphiql_route ( graphiql_path = '/graphiql' , graphql_path = graphql_path , name = 'graphiql' ) # Instantiate the Starlette app _app = Starlette ( routes = [ graphql_route , graphiql_route ], exception_handlers = { HTTPException : http_exception }, on_startup = [ database . connect ], on_shutdown = [ database . disconnect ], ) return _app # Instantiate the app APP = create_app ( connection_str = DATABASE_URI , sqla_models = [ Author , Book ])","title":"Public API"},{"location":"public_api/#reflection","text":"Utilities for reflecting SQL entities as GraphQL entities.","title":"Reflection"},{"location":"public_api/#sqla-to-graphql","text":"nebulo.gql.sqla_to_gql. sqla_models_to_graphql_schema ( sqla_models , sql_functions=None , jwt_identifier=None , jwt_secret=None ) Creates a GraphQL Schema from SQLA Models Parameters sqla_models : List[Type[SQLAModel]] = List of SQLAlchemy models to include in the GraphQL schema jwt_identifier : str = qualified path of SQL composite type to use encode as a JWT e.g. 'public.jwt' jwt_secret : str = Secret key used to encrypt JWT contents sql_functions = NOT PUBLIC API","title":"SQLA to GraphQL"},{"location":"public_api/#server","text":"Helpers to serve the GraphQL schema.","title":"Server"},{"location":"public_api/#routes","text":"nebulo.server.routes. get_graphql_route ( gql_schema , database , path='/' , jwt_secret=None , default_role=None , name=None ) Create a Starlette Route to serve GraphQL requests Parameters schema : Schema = A GraphQL-core schema database : Database = Database object for communicating with PostgreSQL path : str = URL path to serve GraphQL from, e.g. '/' jwt_secret : str = secret key used to encrypt JWT contents default_role : str = Default SQL role to use when serving unauthenticated requests name : str = Name of the GraphQL serving Starlette route nebulo.server.routes. get_graphiql_route ( graphiql_path='/graphiql' , graphql_path='/' , name='graphiql' ) Return mountable routes serving GraphiQL interactive API explorer Parameters graphiql_path : str = URL path to GraphiQL html page graphql_path : str = URL path to the GraphQL route name : str = Name for the mount","title":"Routes"},{"location":"public_api/#exception-handling","text":"nebulo.server.exception. http_exception ( request , exc ) Starlette exception handler converting starlette.exceptions.HTTPException into GraphQL responses","title":"Exception Handling"},{"location":"quickstart/","text":"Quickstart For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulo to reflect our GraphQL API. Finally, we'll query from that API. Installation Requires: Python 3.7+ pip install nebulo Database Setup If you don't have PostgreSQL installed locally, the following docker command creates an instance with the connection string used for the remainder of the quickstart guide. docker run --rm --name nebulo_demo -p 4443 :5432 -d -e POSTGRES_DB = nebulo_db -e POSTGRES_PASSWORD = password -e POSTGRES_USER = nebulo_user -d postgres Next, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. Additionally, we don't want to allow users to update or delete their blog post. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' ); COMMENT ON TABLE blog_post IS E '@exclude update, delete' ; Note the comment to exclude updates and deletes from blog posts. The same comment format can also be applied to exclude columns from reflection e.g. password hashes. GraphQL Schema Now we're ready to reflect the database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulo_user:password@localhost:4443/nebulo_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below type Query { \"\"\"Reads a single Account using its globally unique ID\"\"\" account ( nodeId: ID !): Account \"\"\"Reads and enables pagination through a set of Account\"\"\" allAccounts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: accountCondition ): AccountConnection \"\"\"Reads a single BlogPost using its globally unique ID\"\"\" blogPost ( nodeId: ID !): BlogPost \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" allBlogPosts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection } type Mutation { \"\"\"Creates a single Account.\"\"\" createAccount ( input: CreateAccountInput !): CreateAccountPayload \"\"\"Updates a single Account using its globally unique id and a patch.\"\"\" updateAccount ( input: UpdateAccountInput !): UpdateAccountPayload \"\"\"Delete a single Account using its globally unique id and a patch.\"\"\" deleteAccount ( input: DeleteAccountInput !): DeleteAccountPayload \"\"\"Creates a single BlogPost.\"\"\" createBlogPost ( input: CreateBlogPostInput !): CreateBlogPostPayload } type Account implements NodeInterface { nodeId: ID ! id: Int ! name: String ! createdAt: DateTime ! \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" blogPostsByIdToAuthorId ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection ! } \"\"\"An object with a nodeId\"\"\" interface NodeInterface { \"\"\"The global id of the object.\"\"\" nodeId: ID ! } scalar DateTime type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor < abridged output > Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByIdToAuthorId and accountByAuthorIdToId on their base types respectively. Query the API To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db In addition to handling GraphQL requests, nebulo also serves the GraphiQL explorer locally at http://localhost:5034/graphiql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulo to reflect our GraphQL API. Finally, we'll query from that API.","title":"Quickstart"},{"location":"quickstart/#installation","text":"Requires: Python 3.7+ pip install nebulo","title":"Installation"},{"location":"quickstart/#database-setup","text":"If you don't have PostgreSQL installed locally, the following docker command creates an instance with the connection string used for the remainder of the quickstart guide. docker run --rm --name nebulo_demo -p 4443 :5432 -d -e POSTGRES_DB = nebulo_db -e POSTGRES_PASSWORD = password -e POSTGRES_USER = nebulo_user -d postgres Next, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. Additionally, we don't want to allow users to update or delete their blog post. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' ); COMMENT ON TABLE blog_post IS E '@exclude update, delete' ; Note the comment to exclude updates and deletes from blog posts. The same comment format can also be applied to exclude columns from reflection e.g. password hashes.","title":"Database Setup"},{"location":"quickstart/#graphql-schema","text":"Now we're ready to reflect the database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulo_user:password@localhost:4443/nebulo_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below type Query { \"\"\"Reads a single Account using its globally unique ID\"\"\" account ( nodeId: ID !): Account \"\"\"Reads and enables pagination through a set of Account\"\"\" allAccounts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: accountCondition ): AccountConnection \"\"\"Reads a single BlogPost using its globally unique ID\"\"\" blogPost ( nodeId: ID !): BlogPost \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" allBlogPosts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection } type Mutation { \"\"\"Creates a single Account.\"\"\" createAccount ( input: CreateAccountInput !): CreateAccountPayload \"\"\"Updates a single Account using its globally unique id and a patch.\"\"\" updateAccount ( input: UpdateAccountInput !): UpdateAccountPayload \"\"\"Delete a single Account using its globally unique id and a patch.\"\"\" deleteAccount ( input: DeleteAccountInput !): DeleteAccountPayload \"\"\"Creates a single BlogPost.\"\"\" createBlogPost ( input: CreateBlogPostInput !): CreateBlogPostPayload } type Account implements NodeInterface { nodeId: ID ! id: Int ! name: String ! createdAt: DateTime ! \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" blogPostsByIdToAuthorId ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection ! } \"\"\"An object with a nodeId\"\"\" interface NodeInterface { \"\"\"The global id of the object.\"\"\" nodeId: ID ! } scalar DateTime type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor < abridged output > Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByIdToAuthorId and accountByAuthorIdToId on their base types respectively.","title":"GraphQL Schema"},{"location":"quickstart/#query-the-api","text":"To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db In addition to handling GraphQL requests, nebulo also serves the GraphiQL explorer locally at http://localhost:5034/graphiql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Query the API"},{"location":"row_level_security/","text":"Row Level Security Example The following is a complete example showing how to leverage PostgreSQL row level security with JWTs to restrict data access. row level security example project","title":"Row Level Security"},{"location":"row_level_security/#row-level-security-example","text":"The following is a complete example showing how to leverage PostgreSQL row level security with JWTs to restrict data access. row level security example project","title":"Row Level Security Example"},{"location":"sqlalchemy_interop/","text":"SQLAlchemy Interop Example An example showing how to add a nebulo-powered API to an existing SQLAlchemy project can be found at the link below. SQLAlchemy interop example project","title":"SQLAlchemy Interop"},{"location":"sqlalchemy_interop/#sqlalchemy-interop-example","text":"An example showing how to add a nebulo-powered API to an existing SQLAlchemy project can be found at the link below. SQLAlchemy interop example project","title":"SQLAlchemy Interop Example"},{"location":"supported_entities/","text":"Supported Entities There is automatic reflection support for: Tables Views Functions","title":"Entities"},{"location":"supported_entities/#supported-entities","text":"There is automatic reflection support for: Tables Views Functions","title":"Supported Entities"},{"location":"supported_types/","text":"Supported Types There is first class support for the following PG types: Boolean Integer BigInteger Float Numeric (casts to float) Text Timestamp (as ISO 8601 string) UUID Composite (excludes nested composites) Enum Other, unknown types, default to a String representation.","title":"Types"},{"location":"supported_types/#supported-types","text":"There is first class support for the following PG types: Boolean Integer BigInteger Float Numeric (casts to float) Text Timestamp (as ISO 8601 string) UUID Composite (excludes nested composites) Enum Other, unknown types, default to a String representation.","title":"Supported Types"}]}